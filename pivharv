#!/usr/bin/env ruby

# Workaround for bugged harvested
Dir.chdir(File.dirname(__FILE__)) do

  require 'tempfile'
  require 'shellwords'
  require 'rubygems'
  require 'optparse'
  require 'date'
  require 'dotenv'
  require 'pivotal-tracker'
  require 'harvested'
  require 'colorize'
  require_relative 'config/pivharv/projects'
  require_relative 'lib/terminal_formatting'
  ##############################################################################

  Dotenv.load

  PivotalTracker::Client.token = ENV["PIVOTAL_TRACKER_API_TOKEN"]
  PivotalTracker::Client.timeout = 50
  harvest = Harvest.client(
    subdomain: ENV["HARVEST_SUBDOMAIN"],
    username: ENV["HARVEST_USERNAME"],
    password: ENV["HARVEST_PASSWORD"]
  )
  ##############################################################################

  @options = {
    days_index: 0
  }
  ##############################################################################

  def show(harvest)
    print "Fetching today's Harvest time entries..."
    harvest_time = harvest.time.all(Date.today + @options[:days_index])
    if harvest_time.count > 0
      harvest_time.each_with_index do |time, i|
        print "\r" if i == 0
        puts left_and_right("#{time.project} (#{time.project_id})",
          "#{time.hours} hours").black.on_white
        if time.notes.respond_to? :lines
          time.notes.lines.each do |line|
            puts "    " << line
          end
        end
      end
    else
      print "\r"
      puts "No time today"
    end
  end
  ##############################################################################

  OptionParser.new do |opts|

    opts.banner = "TODO"

    opts.on("-d DAYS_INDEX", OptionParser::DecimalInteger,
    "eg. 1, 2, -1 " <<
    "(default: #{@options[:days_index]})") do |d|
      @options[:days_index] = d
    end

    opts.on("--yesterday") do |yesterday|
      @options[:days_index] = -1
    end

  end.parse!
  ##############################################################################

  if ARGV.length == 0
    # just show harvest, called below
  elsif ARGV.length == 1 && projects[ARGV[0]]
    project = ARGV[0].downcase
    print "Fetching Harvest time entry..."
    time_entry =
      harvest.time.all(Date.today + @options[:days_index]).
      select { |t| t.project_id.to_i == projects[project]["harvest_id"] }.
      first
    print "\r"
    temp_notes = Tempfile.new('pivharv_notes')
    File.write(temp_notes, time_entry.notes)
    temp_notes.rewind
    system "$EDITOR #{temp_notes.path}"
    if File.read(temp_notes) != time_entry.notes
      updated_time_entry = time_entry.update({"notes" => File.read(temp_notes)})
      print "Changes made; updating Harvest time entry..."
      print "\r"
      harvest.time.update(updated_time_entry)
    end
    temp_notes.close
    temp_notes.unlink
  elsif ARGV.length == 3
    project = ARGV[0].downcase
    action = ARGV[1].upcase
    story_id = ARGV[2].gsub(/\D/, '')
    print "Hitting Pivotal Tracker API..."
    if projects[project]["pivotal_tracker_api_token"]
      PivotalTracker::Client.token =
        projects[project]["pivotal_tracker_api_token"]
    end
    story = PivotalTracker::Story.find(
      story_id,
      projects[project]["pivotal_tracker_id"])
    print "\r"
    harvest_line =
      %Q{#{action} [#{story.story_type[0].upcase}] } +
      %Q{[#{story_id}] #{story.name}}
    print "Fetching Harvest time entry..."
    time_entry =
      harvest.time.all(Date.today + @options[:days_index]).
      select { |t| t.project_id.to_i == projects[project]["harvest_id"] }.
      first
    time_entry.notes ||= ""
    print "\r"
    print "Updating Harvest time entry..."
    if time_entry.notes.include? "[#{story_id}]"
      new_notes = time_entry.notes
      new_notes_line_to_replace =
        new_notes.lines.select { |l| l.include? "[#{story_id}]" }.first
      new_notes.sub! new_notes_line_to_replace, (harvest_line + "\n")
      updated_time_entry = time_entry.update(notes: new_notes)
    else
      updated_time_entry = time_entry.update(
        {"notes" => (time_entry.notes.lines.map(&:rstrip) <<
          harvest_line).join("\n")})
    end
    harvest.time.update(updated_time_entry)
    print "\r"
  else
    puts "Bad input"
    exit
  end

  show harvest
end

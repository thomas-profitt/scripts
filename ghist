#!/usr/bin/env ruby

require 'optparse'

require 'colorize'

require_relative 'lib/terminal_formatting' and include TerminalFormatting

options = {regex: false, execute: false, execute_last: false}
history_filenames = Dir[Dir.home << "/.*sh_history"]
query = nil

OptionParser.new do |opts|

  opts.banner =
    ["Usage: ghist [options] QUERY",
    "Searches your shell history file(s) for QUERY",
    "Can also interactively execute found commands"].
    join "\n"

  opts.on("-r", "--regex", "Consider QUERY a Ruby regex") do |r|
    options[:regex] = true
  end

  opts.on("-e", "--execute", "Execute one of the results by number") do |e|
    options[:execute] = true
  end

  opts.on("-E", "--execute-last", "Execute the last matching command") do |e|
    options[:execute_last] = true
  end

end.parse!

if ARGV.empty? || ARGV[0].empty?
  puts "No query provided; exiting"
  abort
end

query = options[:regex] ? Regexp.new(ARGV[0]) : ARGV[0]
history_content = history_filenames.
  map { |s| File.read(s) }.
  join("\n").
  encode('UTF-8', invalid: :replace).
  split("\n").
  map(&:strip).
  uniq
history_matches = history_content.select { |s| s[query] }
colorized_history_matches =
  history_matches.map { |s| s.gsub query, s[query].light_green.bold }

if options[:execute_last]
  puts colorized_history_matches.last
  print "Execute this? [y/N]".yellow + "\n\t> "
  if STDIN.gets.chomp.downcase == "y"
    puts left_and_right("", "Executing").green
    exec history_matches.last
  else
    puts left_and_right("", "Not executed").red
  end
elsif options[:execute]
  colorized_history_matches.each_with_index do |s, i|
    puts i.to_s.yellow << " " << s
  end
  print "Enter an index from above to execute that command:\n\t> "
  input_index = STDIN.gets.to_i
  if history_matches[input_index]
    puts left_and_right("", "Executing").green
    exec history_matches[input_index]
  else
    puts left_and_right("", "Not executed").red
  end
else
  colorized_history_matches.each do |s|
    puts s
  end
end


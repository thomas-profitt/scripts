#!/usr/bin/env ruby

require 'optparse'

begin
  require 'colorize'
  color = true
rescue LoadError
  color = false
end

require_relative 'lib/terminal_formatting' and include TerminalFormatting

options = {
  color: color,
  regex: false,
  execute_interactive: false,
  execute_index: false,
  yes: false
}

history_filenames = Dir[Dir.home << "/.*sh_history"]
query = nil

OptionParser.new do |opts|

  opts.banner =
    ["Usage: ghist [options] QUERY",
    "Searches your shell history file(s) for QUERY",
    "Can also interactively execute found commands.",
    "'colorize' ruby gem " <<
      (color ? "found".light_green.bold : "not found") << "; " <<
      "output will" << (color ? " " : " not ") << "be colorized."].
    join "\n"

  opts.on("-r", "--regex", "Consider QUERY a Ruby regex (without //)") do |r|
    options[:regex] = true
  end

  opts.on("-e", "--execute-interactive",
  "Execute a match by index (interactive)") do |e|
    options[:execute_interactive] = true
  end

  opts.on("-E INDEX", "--execute-index INDEX", OptionParser::DecimalInteger,
  "Execute match at INDEX eg. 0, 1, 2, -1, -2") do |e|
    options[:execute_index] = e
  end

  opts.on("-y", "--yes", "Automatically answer \"yes\" at prompts") do |y|
    options[:yes] = true
  end

  opts.on("-p", "--include-pry-history", "Include ~/.pry_history") do |p|
    options[:include_pry_history] = true
    history_filenames << (Dir.home << "/.pry_history")
  end

end.parse!

if ARGV.empty? || ARGV[0].empty?
  puts "No query provided; exiting"
  abort
end

query = options[:regex] ? Regexp.new(ARGV[0]) : ARGV[0]
history_content = history_filenames.
  map { |s| File.read(s) }.
  join("\n").
  encode('UTF-8', invalid: :replace).
  split("\n").
  map(&:strip).
  uniq
history_matches = history_content.select { |s| s[query] }

if options[:color]
  colorized_history_matches =
    history_matches.map { |s| s.gsub query, s[query].light_green.bold }
end

if options[:execute_index]
  puts(
    if options[:color]
      colorized_history_matches[options[:execute_index]]
    else
      history_matches[options[:execute_index]]
    end)
  print "Execute this? [y/N]".send(options[:color] ? :yellow : :to_s) + "\n\t> "
  if options[:yes] || STDIN.gets.chomp.downcase == "y"
    puts left_and_right("", "Executing").send(options[:color] ? :green : :to_s)
    exec history_matches[options[:execute_index]]
  else
    puts left_and_right("", "Not executed").send(options[:color] ? :red : :to_s)
  end
elsif options[:execute_interactive]
  if options[:color]
    colorized_history_matches.each_with_index do |s, i|
      puts i.to_s.yellow << " " << s
    end
  else
    history_matches.each_with_index do |s, i|
      puts i.to_s << " " << s
    end
  end
  print "Enter an index from above to execute that command:\n\t" <<
    "> ".send(options[:color] ? :yellow : :to_s)
  input_index = STDIN.gets.chomp
  unless input_index.empty?
    input_index = input_index.to_i
  else
    input_index = nil
  end
  if input_index && history_matches[input_index]
    puts left_and_right("", "Executing").send(options[:color] ? :green : :to_s)
    exec history_matches[input_index]
  else
    puts left_and_right("", "Not executed").send(options[:color] ? :red : :to_s)
  end
else
  matches = options[:color] ? colorized_history_matches : history_matches
  matches.each do |s|
    puts s
  end
end

